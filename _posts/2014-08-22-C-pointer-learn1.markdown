---
layout:     post
title:      "彻底理解C指针 -- 解读C的声明、C语言的内存使用方法"
subtitle:   "深入了解C语言指针相关知识。"
date:       2014-08-22
author:     "waynezxcv"
header-img: "img/post.png"
tags:
    - C语言
    - 指针
---

### 目录

1. [解读C语言的声明](#section1)
2. [函数、字符串常量与静态变量的内存使用](#section2)
3. [自动变量-栈的内存使用](#section3)
4. [利用malloc()来进行动态内存分配-堆的内存使用](#section4)
5. [参考](#section5)


***

### 解读C语言的声明

C语言的声明语法是一件很让人头疼的事情。

#### C语言声明的解读

因为C语言是使用的英语的人发明的，所以我们应该按照英语的语法习惯去读（^_^）.这里，介绍用英语习惯阅读C语言声明方法的方法：

1. 首先着眼于标示符（变量名和函数名）
2. 从距离标示符最近的地方开始，依照优先顺序解释派生类型，优先顺序如下：用于整理声明的括弧>用于表示数组的[],用于表示函数的（）>用于表示指针的*
3. 解释完派生类型用"of"、"to"、"returning"将它们连接起来
4. 最后，追加类型修饰符（在左边的int，double等）

一个简单的🌰：

```
int (*func_p)(double)

```
1. 先读标示符func_p
2. 在读用于整理声明的括弧()
3. 读表示指针的*
4. 用to连接派生类型和后面的表函数的（），并读参数
5. 读表示类型的int

即：func_p是一个指针of函数（参数是double），返回int类型

整理成中文：func_p一个是参数是double类型，返回值是int类型的函数指针。

可以看到，C语言的声明不是从左往右读的，而是左右来回读的。

下面是解释各种各样的C语言声明的🌰:

```
int hoge

```

hoge是int类型的变量

***

```
int hoge[10]

```

hoge是有10个int类型元素的数组。

***

```
int *hoge[10]

```
hoge是有10个指向int类型指针元素的数组。
***

```
int (*hoge)[3] 

```
hoge是指向 有3个int类型元素数组的指针。

***

```
int func (int a)

```
func是一个参数为int类型的、返回值为int类型的函数。

***

```
int (*func_p)(int a)

```
func_p是指向参数为int类型，返回值为int类型的函数的指针。

***

```
int (*func_table[10](int a));

```
func_table是有10个指向int类型、参数为int的函数指针元素的数组。

***

#### 函数形参的声明

C语言可以像下面这样声明函数的形参:

```
void func(int a[]) {

}

```
对于这种写法，怎么看都好像要想函数的参数传递数组。可是，在C中是不能够将数组作为函数参数进行传递的。无论如何，在这种情况下，你只能传递**指向数组初始元素的指针**。

即上面写法自动解读成

```
void func(int *a){
}

```
即使你定义了数组的元素个数，也会被无视。

**只有在声明函数形参的情况下，int a[]和int *a才具有相同的意义**。


下面是一个稍微复杂的形参声明的🌰

```
void func(int a[][5])

```
对于C语言，在表达式中的数组可以被解读成“指向初始元素的指针”，函数的参数也是表达式，所以，此时的数组也可以解读成“指向初始元素的指针”

```
vod func(int （*a）[5]) {
}

```
即，传入的参数是指向有5个int元素数组的指针。

***

#### 关于[]下标运算符
在C语言中，遇到以下情况下标运算符可以将元素个数省略不写

1. 函数形参声明（会被当做指针）的情况
2. 根据初始化表达式可以确定数组大小的情况``int a[]= {1,2,3,4,5};//初始化时，元素的个数已经确定了``
3. 使用extern声明全局变量的情况（在多个文件中的某一个定义，从其他代码文件通过extern进行声明）

***

#### 数组和指针是不同的事务
##### 在表达式当中

在表达式当中，数组可以被理解成指向其初始元素的指针。所以，可以写成这样:

```
int *p;
int array[10];

p = array;

```
可是反过来,

```
array = p;

```
是不可以的！以为此时array相当于&array[0],它是一个右值，所以不能被赋值。

>左值是什么？表达式代表某处内存区域的时候，我们称其为左值。

>右值是什么？表达式只是代表值的时候，我们称它为右值。


##### 在声明当中

只有在声明函数的形参的时候，数组的声明才能被解读成指针的声明。

**记住，指针跟数组是不同的事务!**


***
### 函数、字符串常量与静态变量的内存使用

#### 只读内存区域

如今的大多数操作系统都是讲函数自身和字符串字符串常量汇总配置在一个只读内存区域。

#### 静态变量

静态变量是从程序启动到运行结束为止持续存在的变量。因此，静态变量总是在虚拟地址空间上占有固定的区域。静态变量中有全局变量、文件内static变量和指定指定static的局部变量。

*** 

### 自动变量--栈的内存使用
自动变量重复使用内存区域，因此，自动变量的地址是不一定的。

#### 函数调用究竟发生了什么
C语言中，在现有被分配内存区域之上以“堆积”的方式，为新的函数调用分配内存区域。在函数返回的时候，会释放这部分内存区域供下一次函数调用使用。对于像这样使用“堆积”方式的数据结构，我们称之为**栈**。C语言中，通常将自动变量保存在栈上。

C语言调用函数的实现：

1. 在调用方，参数从后往前顺序被堆积在栈中。（参数从后往前是为了实现不定参数的函数）
2. 和调用函数关联的返回信息（返回地址等）也被堆积在栈中，正因为返回地址也被堆积在栈中，所以无论函数从什么地方被调用，它都能返回到调用点的下一个处理。
3. 跳转到作为被调用对象的函数地址。
4. 栈为当前函数所使用的自动变量增长所需大小的内存区域。
5. 在函数执行过程中，为了进行复杂的表达式运算，有时候会将计算过程中的值放在栈中。
6. 一旦函数调用结束，局部变量占用的内存区域被释放，而且使用返回信息返回原来的地址。
7. 从栈中出去调用方的参数。
 

#### 递归调用

C语言通常在栈中分配自动变量的内存区域。处理可以重复使用该区域来节省内存之外，还可以实现递归调用。

##### 快速排序

快速排序的基本思路如下：
1. 从需要排序的数据中，找到一个适当的基准值。
2. 将需要排序的数据按照小于基准值和大于基准值进行分类。
3. 对分类后的两类数据各自再次进行上述的1、2处理。


***

### 利用malloc()来进行动态内存分配--堆

C语言可以使用malloc()进行动态内存分配。malloc()根据参数指定的尺寸来分配内存块，它返回指向内存块初始位置的指针。

```
p = malloc(sizeof(int));

```
一旦内存分配失败（内存不足），malloc（）将返回NULL。
malloc（）分配的内存被使用结束时，通过free()来释放内存。

```
free(p);

```
像这样能够动态地进行内存分配，并且可以通过任意顺序释放的内存区域，成为**堆**。

***

### 参考

《彻底征服C指针》
